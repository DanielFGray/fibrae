{"id":"didact-ts-13e","title":"Core Rewrite: Phase 1 - Core Data Structures","description":"Define RenderNode type, set up graph creation utilities, implement normalizeToStream","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T14:08:29.927483652-06:00","updated_at":"2025-12-22T14:29:39.839230861-06:00","closed_at":"2025-12-22T14:29:39.839230861-06:00","close_reason":"Closed via update","labels":["core","rewrite"]}
{"id":"didact-ts-1t8","title":"Core Rewrite: Phase 3 - Commit Phase","description":"Implement commit(graph): Effect\u003cvoid\u003e. Topological traversal, create DOM elements and wrappers, subscribe to streams with proper scoping, handle first vs subsequent emissions.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T14:08:35.355082076-06:00","updated_at":"2025-12-22T14:29:42.410303858-06:00","closed_at":"2025-12-22T14:29:42.410303858-06:00","close_reason":"Closed via update","labels":["core","rewrite"]}
{"id":"didact-ts-425","title":"Suspense should not use CSS display for visibility toggling","description":"Current Suspense implementation uses `display: none` / `display: contents` to toggle between fallback and children. This is a hack that:\n\n1. Still renders both fallback and children to DOM (wasteful)\n2. Relies on CSS side effects for control flow\n3. Could cause layout/style issues in edge cases\n4. Doesn't match how ErrorBoundary or other special elements work\n\nProper approach:\n- Only render fallback OR children, never both\n- Use DOM insertion/removal, not CSS visibility\n- If timeout fires: render fallback, then when children ready, remove fallback DOM nodes and render children\n- If children win race: never touch fallback at all\n\nThis requires restructuring the race logic to delay child rendering start until we know which path to take, or use a single container with proper scope-based cleanup for swapping.","status":"closed","priority":2,"issue_type":"bug","assignee":"claude","created_at":"2025-12-22T17:17:12.818285939-06:00","updated_at":"2025-12-22T20:40:57.854677254-06:00","closed_at":"2025-12-22T20:40:57.854677254-06:00","close_reason":"Refactored Suspense to use proper DOM insertion/removal instead of CSS display hacks. Children now render to a detached container; if they complete within threshold, we append directly (fallback never rendered). If timeout fires first, we render fallback to DOM, then swap when children are ready (remove fallback, insert children). All tests passing.","labels":["core","suspense","tech-debt"],"dependencies":[{"issue_id":"didact-ts-425","depends_on_id":"didact-ts-awr","type":"blocks","created_at":"2025-12-22T17:17:12.820312537-06:00","created_by":"daemon"}]}
{"id":"didact-ts-450","title":"Todo item removal not working - E2E tests failing","description":"Two E2E tests fail when removing todo items:\n- \"todo list adds and removes items\" - Expected not to find 'Test todo 1' but found it\n- \"multiple todos - can remove each individually\" - Expected not to find 'First todo' but found it\n\nThe remove functionality in TodoList component may not be working correctly, or there's a reactivity issue where the UI doesn't update after removal.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-21T15:12:34.855427368-06:00","updated_at":"2025-12-22T14:33:04.59729021-06:00","closed_at":"2025-12-22T14:33:04.59729021-06:00","close_reason":"Todo item removal is now working - all 10 auto-effect tests pass","labels":["bug","reactivity","testing"]}
{"id":"didact-ts-681","title":"Error Boundary component: catch component/stream failures and render fallback","description":"Implement ErrorBoundary component that catches errors from child components or streams and renders a fallback UI. Should support optional `onError` callback.\n\nCurrent state: Basic ErrorBoundary exists in core.ts (lines 1124-1161) but needs more comprehensive error handling for:\n- Render-time crashes (working - tested in error-boundary.cy.ts)\n- Event handler failures (partially implemented)\n- Stream failures (partially implemented)","notes":"ErrorBoundary currently a passthrough. Need to implement actual error catching for: render-time crashes, event handler Effect failures, stream failures (pre and post first emission)","status":"closed","priority":1,"issue_type":"epic","created_at":"2025-12-21T15:02:43.225045733-06:00","updated_at":"2025-12-22T19:22:18.601863428-06:00","closed_at":"2025-12-22T19:22:18.601863428-06:00","close_reason":"ErrorBoundary epic complete. All error types now handled: render-time crashes, event handler Effect failures, stream failures (pre and post first emission). 4/4 error boundary tests passing. Remaining items (Suspense/ErrorBoundary interaction, demo refactor) are enhancements not blockers.","labels":["error-handling","roadmap"]}
{"id":"didact-ts-6rr","title":"Dev server not running - cannot verify E2E tests","description":"The Vite dev server at localhost:5173 is not running. E2E tests and browser verification require it.\n\nPer AGENTS.md: \"Assume the vite dev server is already running. Do not try to run it with `bun dev`.\"\n\nTests written but cannot be verified until dev server is started.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-21T15:09:02.273995219-06:00","updated_at":"2025-12-21T15:11:02.900119502-06:00","closed_at":"2025-12-21T15:11:02.900119502-06:00","close_reason":"Dev server is running","labels":["blocking","environment"]}
{"id":"didact-ts-8jl","title":"Cypress not installed - E2E tests cannot run","description":"Running `bun --filter demo cypress:run` fails with:\n\n\"No version of Cypress is installed in: /home/dan/.cache/Cypress/15.6.0/Cypress\"\n\nFix: Run `cypress install` from packages/demo directory (Cypress is a demo package dependency, not top-level).","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-21T15:03:15.634401191-06:00","updated_at":"2025-12-21T15:06:55.508619032-06:00","closed_at":"2025-12-21T15:06:55.508619032-06:00","close_reason":"Installed Cypress 15.6.0 via `bun run cypress install` in packages/demo. Tests now run (require dev server at localhost:5173).","labels":["blocking","environment","testing"]}
{"id":"didact-ts-9w8","title":"Verify SSR/hydration compatibility with Atom.family in dynamic lists","description":"From REWRITE_PLAN.md Open Questions:\n- Confirm no change to hydration keys and that idle TTL/disposal is sufficient for families created in dynamic lists\n- Related to SSR/serialization concerns","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-21T15:03:50.46489801-06:00","updated_at":"2025-12-21T15:03:50.46489801-06:00","labels":["atoms","open-question","ssr"]}
{"id":"didact-ts-awr","title":"Implement Suspense as special VElement with threshold-based fallback","description":"Refactor Suspense from returning a Stream to returning a special VElement (like ErrorBoundary). The renderer will handle threshold-based fallback logic using a two-container approach.\n\nKey changes:\n1. Add \"SUSPENSE\" to Primitive type in shared.ts\n2. Change Suspense function to return VElement with type \"SUSPENSE\"\n3. Handle SUSPENSE in renderVElementToDOM with two-container approach\n4. Default threshold: 100ms (configurable per boundary)\n\nAlgorithm:\n- Create two containers (fallback + children)\n- Fork child rendering immediately\n- Race child completion vs timeout\n- If timeout wins: show fallback, wait for children, swap\n- If children win: fallback never rendered","acceptance_criteria":"- Suspense returns VElement with type \"SUSPENSE\"\n- Fast children (\u003c threshold) skip fallback entirely\n- Slow children show fallback then swap to content\n- threshold prop configurable (default 100ms)\n- Existing tests pass","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T17:14:32.402633534-06:00","updated_at":"2025-12-22T17:17:14.149933883-06:00","closed_at":"2025-12-22T17:17:14.149933883-06:00","close_reason":"Basic Suspense as VElement implemented and working. Tests pass. CSS display hack noted as follow-up issue.","labels":["core","rendering","suspense"]}
{"id":"didact-ts-b14","title":"Core Rewrite: Phase 6 - Atom Integration","description":"Tracking registry for auto-subscription, AtomRegistry.toStream for explicit subscription, event handlers that return Effects.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T14:08:42.409419005-06:00","updated_at":"2025-12-22T14:33:07.564218743-06:00","closed_at":"2025-12-22T14:33:07.564218743-06:00","close_reason":"Phase 6 (Atom Integration) complete - tracking registry and subscriptions working","labels":["core","rewrite"]}
{"id":"didact-ts-bn8","title":"Examples page tests need updating for new architecture","description":"Tests expect certain elements/behaviors that don't match current implementation:\n- Stream+Suspense test expects data-cy=\"stream-loading\" but stream completes too fast\n- Debounced search test may have selector issues\n- Counter increment test fixed (chained clicks)\nSection headers now preserved with createSection helper.","notes":"Session update: Services example now passing (6/7 tests). Only debounced search test failing due to Cypress element detachment issue during re-render. Need to: 1) Clean up debug logging, 2) Fix debounced search test structure.","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T14:33:18.777096158-06:00","updated_at":"2025-12-22T19:15:29.427412289-06:00","closed_at":"2025-12-22T19:15:29.427412289-06:00","close_reason":"All 7 examples page tests now passing: headers, counter, stream+suspense, todo list (add/remove), todo list (mark complete), debounced search, services. Fixed services layer composition issue and simplified debounced search test for controlled input re-render behavior.","labels":["examples","testing"]}
{"id":"didact-ts-bvw","title":"Effect Services example fails - AtomRegistry service not found","description":"## Root Cause Analysis\n\nThe services example fails because `ThemeService.Default` requires `AtomRegistry.AtomRegistry` as a dependency, but `DidactRuntime.Live` (which is `DidactRuntime.Default`) does NOT expose it as an output.\n\n### The Problem\n\n`DidactRuntime` is defined with:\n```typescript\nclass DidactRuntime extends Effect.Service\u003cDidactRuntime\u003e()(\"DidactRuntime\", {\n  dependencies: [CustomAtomRegistryLayer],  // \u003c-- AtomRegistry consumed here\n  scoped: Effect.gen(function*() {\n    const registry = yield* AtomRegistry.AtomRegistry;\n    // ...\n  }),\n})\n```\n\nThe `dependencies` field makes `CustomAtomRegistryLayer` available INTERNALLY to build `DidactRuntime`, but it does NOT re-export `AtomRegistry.AtomRegistry` as part of the layer's output.\n\nWhen we do:\n```typescript\nLayer.provideMerge(serviceLayer, DidactRuntime.Live)\n```\n\n- `DidactRuntime.Live` outputs: `DidactRuntime` ✓\n- `DidactRuntime.Live` outputs: `AtomRegistry.AtomRegistry` ✗ (consumed but not re-exported)\n- `serviceLayer` (ThemeService.Default) needs: `AtomRegistry.AtomRegistry` ✗ NOT AVAILABLE\n\n### The Fix\n\nEnsure `AtomRegistry.AtomRegistry` is exposed as a layer output, not just consumed internally.\n\n**Option 1** (Preferred): Modify `render()` to merge layers correctly:\n```typescript\nEffect.provide(\n  Layer.provideMerge(\n    options.layer, \n    Layer.merge(DidactRuntime.Default, CustomAtomRegistryLayer)\n  )\n)\n```\n\n**Option 2**: Create a dedicated export that includes both:\n```typescript\nstatic LiveWithRegistry = Layer.merge(DidactRuntime.Default, CustomAtomRegistryLayer);\n```\n\n**Option 3**: Use `Layer.provide` chain instead of `dependencies`:\nRemove the `dependencies` field and compose layers explicitly.\n\n### Previous Attempts (Incorrect)\n\nEarlier we tried capturing `FiberRef.currentContext` and using `Stream.provideContext`, but this doesn't help because the layer never successfully builds in the first place - `ThemeService.Default` fails during layer construction due to missing `AtomRegistry.AtomRegistry`.","notes":"Diagnosis complete. Root cause: Layer dependency vs output semantics. Fix is straightforward - need to expose AtomRegistry as layer output.","status":"closed","priority":2,"issue_type":"bug","created_at":"2025-12-21T15:12:38.686153386-06:00","updated_at":"2025-12-22T19:11:20.219944876-06:00","closed_at":"2025-12-22T19:11:20.219944876-06:00","close_reason":"Fixed by adding `DidactRuntime.LiveWithRegistry` layer that exports both DidactRuntime AND AtomRegistry. When user provides a layer via `render(element, container, { layer })`, we now use `LiveWithRegistry` instead of `Live` so user layers that need AtomRegistry can access it.","labels":["atoms","bug","services"]}
{"id":"didact-ts-clj","title":"Core Rewrite: Phase 4 - Updates","description":"On stream emission, find affected subtree in graph. Close child scope, re-render subtree. Partial graph update (only affected nodes).","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T14:08:37.671653658-06:00","updated_at":"2025-12-22T14:33:05.663187193-06:00","closed_at":"2025-12-22T14:33:05.663187193-06:00","close_reason":"Phase 4 (Updates) complete - reactivity via atom subscriptions working","labels":["core","rewrite"]}
{"id":"didact-ts-ddc","title":"TODO in demo-effect.tsx: add error boundaries to avoid independent renderers","description":"Line 22-23 of demo-effect.tsx has a TODO:\n\"for testing purposes we are doing independent renderers to avoid crashing the whole app for one broken part\nTODO: add error boundaries so we dont need this\"\n\nOnce ErrorBoundary is fully working, refactor demo-effect.tsx to use a single renderer with ErrorBoundary wrapping.","status":"closed","priority":3,"issue_type":"chore","created_at":"2025-12-21T15:03:02.103014159-06:00","updated_at":"2025-12-22T20:34:11.986847236-06:00","closed_at":"2025-12-22T20:34:11.986847236-06:00","close_reason":"Demo refactored to use ErrorBoundary wrappers. All tests passing (basic-render 5/5, examples-page 7/7, error-boundary 4/4).","labels":["demo","tech-debt"],"dependencies":[{"issue_id":"didact-ts-ddc","depends_on_id":"didact-ts-681","type":"related","created_at":"2025-12-21T15:03:10.864155513-06:00","created_by":"daemon"}]}
{"id":"didact-ts-dvf","title":"Stream errors: surface pre-first-emission failures to boundary","description":"Stream errors that occur before the first emission should be caught and surfaced to the nearest ErrorBoundary. Currently the error handling in updateFunctionComponent (lines 388-396) catches stream failures but needs testing.\n\nTerminate subscription on later failures and trigger boundary.","notes":"Deferred pending full core.ts rewrite. The current architecture has fundamental timing issues that a rewrite will address. See REWRITE_PLAN.md for the new architecture.","status":"closed","priority":1,"issue_type":"feature","created_at":"2025-12-21T15:02:47.226084403-06:00","updated_at":"2025-12-22T19:22:16.197821263-06:00","closed_at":"2025-12-22T19:22:16.197821263-06:00","close_reason":"Stream errors both before and after first emission now trigger ErrorBoundary via ErrorBoundaryChannel. All 4 error boundary tests passing.","labels":["error-handling","roadmap","streams"],"dependencies":[{"issue_id":"didact-ts-dvf","depends_on_id":"didact-ts-681","type":"parent-child","created_at":"2025-12-21T15:03:07.874928391-06:00","created_by":"daemon"}]}
{"id":"didact-ts-e3a","title":"Consider API for ephemeral component-local atoms with lifecycle","description":"From REWRITE_PLAN.md Open Questions:\n- Do we need an explicit API for ephemeral, component-local atoms with proper lifecycle? \n- If yes, define constraints and cleanup semantics using component scope.\n\nThis would allow for component-local state similar to React's useState but with Effect Atom semantics.","status":"open","priority":3,"issue_type":"feature","created_at":"2025-12-21T15:03:43.134568213-06:00","updated_at":"2025-12-21T15:03:43.134568213-06:00","labels":["api-design","atoms","open-question"]}
{"id":"didact-ts-fnx","title":"Add E2E tests for error scenarios","description":"Add comprehensive E2E tests for error handling:\n- Thrown component error renders ErrorBoundary fallback\n- Failing event Effect triggers ErrorBoundary  \n- Failing Stream triggers ErrorBoundary\n- Verify Suspense fallback is suppressed when ErrorBoundary has error\n\nCurrent test in error-boundary.cy.ts only tests render-time crash.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-21T15:02:54.760220868-06:00","updated_at":"2025-12-21T15:12:42.270127979-06:00","closed_at":"2025-12-21T15:12:42.270127979-06:00","close_reason":"Added 3 E2E tests for error scenarios:\n1. Render-time crash shows fallback\n2. Event handler Effect failure shows fallback  \n3. Stream failure after first emission shows fallback\n\nAll 3 tests pass. Also added EventFailer and StreamFailer components to examples-page.tsx with ErrorBoundary wrappers.","labels":["roadmap","testing"],"dependencies":[{"issue_id":"didact-ts-fnx","depends_on_id":"didact-ts-681","type":"parent-child","created_at":"2025-12-21T15:03:09.828947402-06:00","created_by":"daemon"}]}
{"id":"didact-ts-g26","title":"Core Rewrite: Phase 5 - Cleanup","description":"Implement unmount: close root scope. All child scopes cascade-close automatically.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T14:08:39.755082314-06:00","updated_at":"2025-12-22T14:33:06.63619041-06:00","closed_at":"2025-12-22T14:33:06.63619041-06:00","close_reason":"Phase 5 (Cleanup) complete - wrapper spans with display:contents","labels":["core","rewrite"]}
{"id":"didact-ts-i87","title":"Fix rapid-click test failures - DOM detachment during re-render","description":"When clicking rapidly, the DOM element is replaced during re-render causing Cypress to fail with 'element detached from DOM'. Need to either implement DOM diffing/patching or update tests to requery elements between clicks.","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-22T14:29:45.529653951-06:00","updated_at":"2025-12-22T14:31:27.935038817-06:00","closed_at":"2025-12-22T14:31:27.935038817-06:00","close_reason":"Fixed tests by requerying elements between clicks instead of chaining .click().click()","labels":["bug","reactivity","testing"]}
{"id":"didact-ts-ia8","title":"Complete ErrorBoundary implementation","description":"ErrorBoundary partial implementation done but needs completion:\n- Catches render-time crashes (throw in component function)\n- Catches stream failures before first emission\n- Still uses innerHTML for cleanup (blocked by didact-ts-ypo)\n- Event handler Effect failures need testing\n- Stream failures after first emission need work (currently forked, errors logged but not caught by boundary)","notes":"Implementing async error propagation via Deferred error channel. Design:\\n1. ErrorBoundaryChannel - Deferred that children can fail to report errors\\n2. ErrorBoundary creates channel, provides via context, listens for errors\\n3. Event handlers and stream subscriptions fail channel on error\\n4. ErrorBoundary catches and renders fallback","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T14:36:33.431265215-06:00","updated_at":"2025-12-22T19:22:00.15987157-06:00","closed_at":"2025-12-22T19:22:00.15987157-06:00","close_reason":"ErrorBoundary now catches all error types: 1) Render-time crashes (sync throws), 2) Stream failures before first emission, 3) Event handler Effect failures (async via ErrorBoundaryChannel), 4) Stream failures after first emission (async via ErrorBoundaryChannel). All 4 tests passing.","labels":["core","error-handling"],"dependencies":[{"issue_id":"didact-ts-ia8","depends_on_id":"didact-ts-ypo","type":"blocks","created_at":"2025-12-22T14:36:33.438368945-06:00","created_by":"daemon"}]}
{"id":"didact-ts-iuz","title":"Investigate AtomRegistry patterns from jotai-effect React bindings","description":"The current tracking registry pattern using Proxy may not be the most idiomatic approach. Investigate how @effect-atom/atom (which is based on jotai) handles registry patterns in its React bindings.\n\nAreas to investigate:\n- How does jotai-effect handle atom tracking in React components?\n- Is there a better pattern than wrapping the registry in a Proxy?\n- How do they handle re-renders and dependency tracking?\n- Are there built-in APIs we should be using instead?\n\nRelevant code: `makeTrackingRegistry` function in core.ts that creates a Proxy around the registry to track accessed atoms.","notes":"## Research Findings - Deep Dive\n\n### The Core Problem\n\n**`Atom.get(atom)` (Effect API)** just calls `registry.get(atom)` - no dependency tracking!\n\n```typescript\n// From Atom.ts line 1952\nexport const get = \u003cA\u003e(self: Atom\u003cA\u003e): Effect.Effect\u003cA, never, AtomRegistry\u003e =\u003e\n  Effect.map(AtomRegistry, (_) =\u003e _.get(self))\n```\n\n**`get(atom)` inside an atom's `read` function** - THIS is where tracking happens:\n\n```typescript\n// From registry.ts line 729-739 (Lifetime.get)\nget\u003cA\u003e(this: Lifetime\u003cany\u003e, atom: Atom\u003cA\u003e): A {\n  if (this.disposed) throw disposedError(this.node.atom)\n  const parent = this.node.registry.ensureNode(atom)\n  this.node.addParent(parent)  // \u003c-- TRACKING!\n  return parent.value()\n}\n```\n\n### Why Our Proxy Approach Still Works\n\nSince `Atom.get()` in Effects uses `registry.get()`, and we provide a tracking registry to the component's Effect context, our Proxy intercepts those calls. The tracking works because:\n\n1. Component Effect runs with `contextWithTracking` \n2. `yield* Atom.get(myAtom)` accesses `AtomRegistry.AtomRegistry` from context → gets our Proxy\n3. Proxy's `get` trap intercepts the call to `registry.get(myAtom)` and adds to `accessedAtoms`\n\n### Improvement Made: Switch from Streams to registry.subscribe\n\n**Before (stream-based subscriptions):**\n```typescript\nconst atomStream = AtomRegistry.toStream(runtime.registry, atom).pipe(\n  Stream.drop(1) // Skip initial value\n);\nconst sub = Stream.runForEach(atomStream, () =\u003e Effect.sync(onUpdate));\nreturn Effect.forkIn(sub, scope);\n```\n\n**After (direct subscriptions like atom-react):**\n```typescript\n// Subscribe immediately - returns unsubscribe function\nconst unsubscribe = runtime.registry.subscribe(atom, onUpdate);\n// Register unsubscribe to run when scope closes\nyield* Scope.addFinalizer(scope, Effect.sync(unsubscribe));\n```\n\nThis is:\n- Simpler (no stream overhead)\n- More efficient (synchronous subscription)\n- Aligned with how atom-react does it\n\n### Bug Fixes During Investigation\n\nFixed demo components in `components.tsx`:\n1. `addTodo`/`removeTodo` now return `Effect.sync(...)` instead of void\n2. TodoList uses `yield* Atom.get(todosAtom)` instead of `registry.get(todosAtom)`\n3. TodoItem uses `yield* Atom.get(...)` for consistency\n\nAll 30 E2E tests now pass.","status":"closed","priority":2,"issue_type":"task","assignee":"claude","created_at":"2025-12-22T16:37:39.58023386-06:00","updated_at":"2025-12-22T21:34:55.884222018-06:00","closed_at":"2025-12-22T21:34:55.884222018-06:00","close_reason":"Completed: Switched from stream-based subscriptions to registry.subscribe (like atom-react), fixed demo component bugs. All 30 tests pass.","labels":["atoms","patterns","research"]}
{"id":"didact-ts-lw3","title":"Replace runHead + drop(1) with Stream.peel pattern","description":"Current code uses `Stream.runHead(stream)` to get first emission, then `stream.pipe(Stream.drop(1))` for remaining emissions. This is problematic because:\n1. Streams aren't replayable - calling drop(1) on same reference may not work as expected\n2. Awkward pattern that's not idiomatic Effect\n\nBetter approach: Use `Stream.peel(stream, Sink.head())` which returns `[Option\u003cfirst\u003e, remainingStream]` properly separating first emission from the rest.\n\n```typescript\n// Before (problematic)\nconst maybeFirst = yield* Stream.runHead(stream);\nconst remainingStream = stream.pipe(Stream.drop(1));\n\n// After (correct)  \nconst [maybeFirst, remainingStream] = yield* Stream.peel(stream, Sink.head());\n```\n\nLocation: `renderVElementToDOM` function component handling in core.ts","notes":"## Analysis\n\nThe `Stream.peel` signature requires a `Scope` in its context:\n```typescript\nStream.peel(stream, sink): Effect\u003c[A2, Stream\u003cA, E, never\u003e], E, Scope.Scope | R\u003e\n```\n\n**Key insight from docs**: \"Like all scoped values, the provided stream is valid only within the scope.\"\n\nThe problem with `Effect.scoped(...)`:\n- Creates a temporary scope that closes when the block returns\n- We fork a subscription to `remainingStream` inside that scope\n- When `Effect.scoped` returns, it closes the scope, invalidating `remainingStream`\n- The forked subscription then fails because the stream's scope is closed\n\n**Solution**: Instead of `Effect.scoped`, provide `componentScope` to the peel effect:\n```typescript\nconst [maybeFirst, remainingStream] = yield* Stream.peel(stream, Sink.head()).pipe(\n  Effect.provideService(Scope.Scope, componentScope)\n);\n```\n\nThis ties the `remainingStream` lifecycle to `componentScope` which lives for the component's lifetime.\n\n## Implementation\n1. Remove `Effect.scoped(...)` wrapper\n2. Use `Effect.provideService(Scope.Scope, componentScope)` on the peel effect\n3. Keep the subscription forked into `componentScope`","status":"closed","priority":2,"issue_type":"task","created_at":"2025-12-22T14:49:27.233897088-06:00","updated_at":"2025-12-22T16:51:22.952077548-06:00","closed_at":"2025-12-22T16:51:22.952077548-06:00","close_reason":"Stream.peel now correctly uses componentScope so remaining stream stays valid. Both stream-components tests pass.","labels":["core","refactor","streams"]}
{"id":"didact-ts-n6u","title":"Replace module-scoped mutable variables with Effect Refs/Services","description":"Current core.ts uses module-scoped mutable variables inside Effect.gen closures:\n- `let output: unknown` for component invocation result\n- `let newOutput: unknown` in re-render callback\n- Mutable `accessedAtoms` Set passed around\n\nShould use Effect-native patterns:\n- Ref for mutable state within Effects\n- Services for shared context\n- Avoid mutation in favor of Effect composition\n\nThis makes testing harder and breaks referential transparency.","status":"closed","priority":2,"issue_type":"chore","assignee":"claude","created_at":"2025-12-22T14:38:10.824244566-06:00","updated_at":"2025-12-22T21:03:11.660621176-06:00","closed_at":"2025-12-22T21:03:11.660621176-06:00","close_reason":"Replaced `let output` and `let newOutput` try/catch patterns with `Effect.try({ try: ..., catch: ... })`. This is the idiomatic Effect way to handle sync exceptions.\n\nThe `accessedAtoms` Set was reviewed and determined to be acceptable:\n- It's locally scoped (not module-scoped as originally thought)\n- Mutation is contained to component invocation window\n- It's effectively immutable after that (only read for subscriptions)\n- Changing to Ref would require API changes since registry.get() is sync\n\nAll 17 tests passing.","labels":["core","effect-patterns","tech-debt"]}
{"id":"didact-ts-suv","title":"Evaluate if registry methods beyond `get` need tracking","description":"From REWRITE_PLAN.md Open Questions:\n- Any additional registry methods that should be tracked beyond `get`? \n- Current approach focuses on read-tracking only via Proxy wrapper.\n\nConsider if `modify` or other methods also need tracking for reactivity.","status":"open","priority":3,"issue_type":"task","created_at":"2025-12-21T15:03:46.789429691-06:00","updated_at":"2025-12-21T15:03:46.789429691-06:00","labels":["atoms","open-question","reactivity"]}
{"id":"didact-ts-tpv","title":"Suspense/ErrorBoundary interaction: error state takes precedence over fallback","description":"When a component wrapped in both Suspense and ErrorBoundary fails, the ErrorBoundary should take precedence. Error state should be displayed instead of loading fallback.\n\nThis requires careful coordination between the Suspense and ErrorBoundary components.","status":"closed","priority":2,"issue_type":"feature","created_at":"2025-12-21T15:02:50.467578576-06:00","updated_at":"2025-12-22T20:44:05.978295477-06:00","closed_at":"2025-12-22T20:44:05.978295477-06:00","close_reason":"Verified that ErrorBoundary takes precedence over Suspense fallback. When a child wrapped in both fails, ErrorBoundary catches the error and closes its content scope, which cleans up the Suspense fallback wrapper. Added E2E test to verify. All tests passing (17/17).","labels":["error-handling","roadmap","suspense"],"dependencies":[{"issue_id":"didact-ts-tpv","depends_on_id":"didact-ts-681","type":"parent-child","created_at":"2025-12-21T15:03:08.813957037-06:00","created_by":"daemon"}]}
{"id":"didact-ts-ypo","title":"Replace innerHTML hacks with proper DOM cleanup via Scope","description":"Current core.ts uses `innerHTML = \"\"` in 4 places to clear DOM content:\n- Line 260: Re-render on atom change\n- Line 299: Stream subsequent emissions\n- Line 339: ErrorBoundary caught error\n- Line 438: Initial render\n\nProblems with innerHTML:\n1. Doesn't properly clean up event listeners\n2. Doesn't respect scopes/subscriptions (memory leaks)\n3. Loses DOM state (focus, selection, scroll position)\n\nProper solution:\n- Track children nodes per wrapper\n- Use Scope for cleanup - when scope closes, remove DOM nodes and unsubscribe\n- For re-renders, close old scope (cleanup) then render fresh\n- Consider using Scope.addFinalizer to register DOM node removal","notes":"Scope-based cleanup implemented and working. Stream.peel fix applied. Now implementing Suspense as special VElement type (related task created).","status":"closed","priority":1,"issue_type":"bug","created_at":"2025-12-22T14:36:20.326611012-06:00","updated_at":"2025-12-22T17:24:28.435681934-06:00","closed_at":"2025-12-22T17:24:28.435681934-06:00","close_reason":"All innerHTML usages removed from core.ts. Using Scope-based cleanup with registerNodeCleanup/clearContentScope for DOM management. render() now uses removeChild loop with warning for non-empty containers.","labels":["bug","cleanup","core","tech-debt"]}
{"id":"didact-ts-yzq","title":"Core Rewrite: Phase 2 - Render Phase","description":"Implement render(vElement): Effect\u003cGraph\u003cRenderNode, void\u003e\u003e. Walk VElement tree, build graph nodes, handle component invocation. No DOM, no subscriptions.","status":"closed","priority":1,"issue_type":"task","created_at":"2025-12-22T14:08:32.797665422-06:00","updated_at":"2025-12-22T14:29:41.09669405-06:00","closed_at":"2025-12-22T14:29:41.09669405-06:00","close_reason":"Closed via update","labels":["core","rewrite"]}
